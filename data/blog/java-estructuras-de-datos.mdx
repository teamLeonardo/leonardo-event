---
title: 'Estructuras de Datos en Java: Una Guía para Principiantes 2024'
date: '2023-11-17'
tags: ['Java']
draft: false
summary: Esta guía ayudará a los principiantes a comprender qué son las estructuras de datos, qué son las estructuras de datos en Java, los tipos de estructuras de datos en Java y mucho más
---

<TOCInline toc={props.toc} exclude="Introduction" />


# ¿Qué es Java?
Java es un lenguaje de programación ampliamente utilizado conocido por su independencia de plataforma y versatilidad. Fue diseñado para tener la menor cantidad de dependencias de implementación posible, lo que permite a los desarrolladores escribir código que se ejecute en cualquier plataforma compatible con Java.

# ¿Qué son las Estructuras de Datos en Java?
En Java, las estructuras de datos son componentes esenciales que permiten la manipulación y almacenamiento eficientes de datos. Incluyen varios tipos como arrays, listas enlazadas, pilas, colas, árboles, grafos y más.

# Tipos de Estructuras de Datos en Java

### Arrays
Los arrays en Java son estructuras de datos que almacenan un conjunto fijo de elementos del mismo tipo. Están diseñados para contener elementos del mismo tipo de datos, y se accede a estos elementos mediante un índice.

**Características de los Arrays en Java:**

-   **Tamaño Fijo:** Los arrays en Java tienen un tamaño fijo que se establece al crearlos y no puede modificarse dinámicamente.
    
-   **Almacenamiento Secuencial:** Los elementos se almacenan de forma secuencial en la memoria, ocupando posiciones contiguas.
    
-   **Acceso mediante Índices:** Cada elemento dentro del array tiene un índice asociado, permitiendo un acceso directo a cualquier elemento a través de su posición.
    

Ejemplo de Array en Java:
```java:code
// Declaración e inicialización de un array de enteros
int[] numeros = new int[5]; // Un array de tamaño 5

// Asignar valores a los elementos del array
numeros[0] = 10;
numeros[1] = 20;
numeros[2] = 30;
numeros[3] = 40;
numeros[4] = 50;

// Acceder a los elementos del array
System.out.println("Elemento en la posición 3: " + numeros[2]); 
// Salida: Elemento en la posición 3: 30

```
### Linked Lists ( listas enlazadas )
Las listas enlazadas son estructuras de datos dinámicas que consisten en nodos conectados entre sí. Cada nodo contiene un valor y una referencia al siguiente nodo en la secuencia. En Java, las listas enlazadas son implementadas mediante las clases LinkedList o implementando una propia.

**Características de las Linked Lists en Java:**

-   **Nodos Enlazados:** Cada nodo contiene un elemento de datos y una referencia al siguiente nodo en la secuencia.
    
-   **Flexibilidad en el Tamaño:** A diferencia de los arrays, las listas enlazadas pueden crecer o reducir su tamaño durante la ejecución del programa.
    
-   **Acceso Secuencial:** Para acceder a un elemento en una lista enlazada, se debe recorrer la lista desde el principio o desde un punto de referencia.

Ejemplo de LinkedList en Java:

```java 
// Creación de una lista enlazada
LinkedList<String> listaEnlazada = new LinkedList<>();

// Agregar elementos a la lista enlazada
listaEnlazada.add("Manzana");
listaEnlazada.add("Naranja");
listaEnlazada.add("Banana");

// Acceder a elementos por índice
System.out.println("Elemento en la posición 1: " + listaEnlazada.get(0)); 
// Salida: Elemento en la posición 1: Manzana

// Eliminar un elemento de la lista
listaEnlazada.remove("Naranja");
```


### Stack ( pila )
Es una estructura de datos basada en el principio LIFO (Last In, First Out), lo que significa que el último elemento agregado es el primero en ser eliminado. En Java, se puede implementar utilizando la clase `Stack` o mediante el uso de la interfaz `Deque` con el método `push` y `pop`.

**Características del Stack en Java:**

-   **Operaciones Fundamentales:** Principalmente admite dos operaciones: `push` para agregar un elemento y `pop` para eliminar el último elemento agregado.
    
-   **Acceso Restringido:** Solo se puede acceder al elemento superior (último agregado) sin alterar otros elementos.
    
Ejemplo de Stack en Java:

```java
// Creación de un Stack
Stack<Integer> pila = new Stack<>();

// Agregar elementos a la pila
pila.push(10);
pila.push(20);
pila.push(30);

// Eliminar elemento superior de la pila
int elementoEliminado = pila.pop();
System.out.println("Elemento eliminado: " + elementoEliminado); 
// Salida: Elemento eliminado: 30

// Acceder al elemento superior sin eliminarlo
int elementoSuperior = pila.peek();
System.out.println("Elemento superior: " + elementoSuperior);
// Salida: Elemento superior: 20
```
### Queue ( cola )
Sigue el principio FIFO (First In, First Out), donde el primer elemento agregado es el primero en ser eliminado. En Java, se puede implementar utilizando la interfaz `Queue` o la clase `LinkedList`.

**Características de Queue en Java:**

-   **Operaciones Fundamentales:** Principalmente, admite operaciones como `offer` para agregar un elemento, `poll` para eliminar el primer elemento y `peek` para ver el primer elemento sin eliminarlo.
    
-   **Utilizado en Procesos Secuenciales:** Es útil en situaciones donde se requiere un procesamiento ordenado de elementos.
    
Ejemplo de Queue en Java:
```java
// Creación de una Queue
Queue<Integer> cola = new LinkedList<>();

// Agregar elementos a la cola
cola.offer(10);
cola.offer(20);
cola.offer(30);

// Eliminar elemento de la cola
int elementoEliminado = cola.poll();
System.out.println("Elemento eliminado: " + elementoEliminado); 
// Salida: Elemento eliminado: 10

// Acceder al primer elemento sin eliminarlo
int primerElemento = cola.peek();
System.out.println("Primer elemento: " + primerElemento); 
// Salida: Primer elemento: 20
```
### Binary Tree ( árbol binario )
Un árbol binario es una estructura de datos jerárquica que consta de nodos, donde cada nodo tiene como máximo dos hijos: uno izquierdo y otro derecho. En un árbol binario, cada nodo puede tener cero, uno o dos hijos.

**Características del Árbol Binario en Java:**

-   **Raíz y Nodos:** El nodo superior se llama raíz. Los nodos que no tienen hijos se llaman hojas.
    
-   **Recorrido:** Hay tres formas principales de recorrer un árbol binario: preorden, inorden y postorden.
    
-   **Operaciones Básicas:** Incluyen la inserción, eliminación y búsqueda de nodos.
    
Ejemplo de Árbol Binario en Java:

```java 
class Nodo {
    int data;
    Nodo izquierda, derecha;

    public Nodo(int item) {
        data = item;
        izquierda = derecha = null;
    }
}

class ArbolBinario {
    Nodo raiz;

    ArbolBinario() {
        raiz = null;
    }

    void insertar(int data) {
        raiz = insertarRec(raiz, data);
    }

    Nodo insertarRec(Nodo raiz, int data) {
        if (raiz == null) {
            raiz = new Nodo(data);
            return raiz;
        }
        if (data < raiz.data)
            raiz.izquierda = insertarRec(raiz.izquierda, data);
        else if (data > raiz.data)
            raiz.derecha = insertarRec(raiz.derecha, data);
        return raiz;
    }

    void inOrder() {
        inOrderRec(raiz);
    }

    void inOrderRec(Nodo raiz) {
        if (raiz != null) {
            inOrderRec(raiz.izquierda);
            System.out.print(raiz.data + " ");
            inOrderRec(raiz.derecha);
        }
    }

    public static void main(String[] args) {
        ArbolBinario tree = new ArbolBinario();
        tree.insertar(50);
        tree.insertar(30);
        tree.insertar(20);
        tree.insertar(40);
        tree.insertar(70);
        tree.insertar(60);
        tree.insertar(80);

        System.out.println("Recorrido inorden del árbol:");
        tree.inOrder(); // Salida: 20 30 40 50 60 70 80
    }
}

```

### Binary Search Tree ( BST )
Es un tipo especial de árbol binario en el que para cada nodo, todos los nodos en el subárbol izquierdo tienen valores menores que el nodo y todos los nodos en el subárbol derecho tienen valores mayores.

**Características del Binary Search Tree en Java:**

-   **Ordenamiento:** Los BST mantienen un orden ascendente o descendente según su estructura.
    
-   **Eficiencia:** Permite realizar búsquedas, inserciones y eliminaciones de manera eficiente.
    
-   **Recorrido:** Los recorridos inorden de un BST producen una secuencia ordenada.
    
Ejemplo de Binary Search Tree en Java:

```java
class NodoBST {
    int valor;
    NodoBST izquierda, derecha;

    public NodoBST(int item) {
        valor = item;
        izquierda = derecha = null;
    }
}

class ArbolBST {
    NodoBST raiz;

    ArbolBST() {
        raiz = null;
    }

    void insertar(int valor) {
        raiz = insertarRec(raiz, valor);
    }

    NodoBST insertarRec(NodoBST raiz, int valor) {
        if (raiz == null) {
            raiz = new NodoBST(valor);
            return raiz;
        }
        if (valor < raiz.valor)
            raiz.izquierda = insertarRec(raiz.izquierda, valor);
        else if (valor > raiz.valor)
            raiz.derecha = insertarRec(raiz.derecha, valor);
        return raiz;
    }

    void inOrder() {
        inOrderRec(raiz);
    }

    void inOrderRec(NodoBST raiz) {
        if (raiz != null) {
            inOrderRec(raiz.izquierda);
            System.out.print(raiz.valor + " ");
            inOrderRec(raiz.derecha);
        }
    }

    public static void main(String[] args) {
        ArbolBST tree = new ArbolBST();
        tree.insertar(50);
        tree.insertar(30);
        tree.insertar(20);
        tree.insertar(40);
        tree.insertar(70);
        tree.insertar(60);
        tree.insertar(80);

        System.out.println("Recorrido inorden del BST:");
        tree.inOrder(); // Salida: 20 30 40 50 60 70 80
    }
}

```
### Heap
Es una estructura de datos de árbol binario especial donde el valor de cada nodo es menor o mayor que los valores de sus nodos hijos, dependiendo de si es un Min Heap o un Max Heap, respectivamente.

**Características del Heap en Java:**

-   **Min Heap y Max Heap:** Puede ser un Min Heap (el nodo raíz es el valor mínimo) o un Max Heap (el nodo raíz es el valor máximo).
-   **Estructura Completa:** Un heap es una estructura de árbol completa, lo que significa que todos los niveles están completamente llenos excepto posiblemente el último nivel, que está lleno de izquierda a derecha.
-   **Acceso Eficiente:** El acceso al elemento más pequeño (en un Min Heap) o más grande (en un Max Heap) es constante.

Ejemplo de Heap en Java:

```java 
import java.util.*;

class Heap {
    PriorityQueue<Integer> minHeap = new PriorityQueue<>(); // Min Heap
    // Para crear un Max Heap, se puede invertir la 
    // comparación usando Collections.reverseOrder()
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());

    void insertMinHeap(int val) {
        minHeap.add(val);
    }

    void insertMaxHeap(int val) {
        maxHeap.add(val);
    }

    int extractMin() {
        return minHeap.poll();
    }

    int extractMax() {
        return maxHeap.poll();
    }

    public static void main(String[] args) {
        Heap heap = new Heap();
        heap.insertMinHeap(4);
        heap.insertMinHeap(9);
        heap.insertMinHeap(2);
        heap.insertMinHeap(5);

        System.out.println("Min Heap:");
        while (!heap.minHeap.isEmpty()) {
            System.out.print(heap.extractMin() + " "); 
            // Salida: 2 4 5 9
        }

        heap.insertMaxHeap(4);
        heap.insertMaxHeap(9);
        heap.insertMaxHeap(2);
        heap.insertMaxHeap(5);

        System.out.println("\nMax Heap:");
        while (!heap.maxHeap.isEmpty()) {
            System.out.print(heap.extractMax() + " "); 
            // Salida: 9 5 4 2
        }
    }
}

```
### Hashing
Es una técnica que se utiliza para mapear datos de tamaño variable a datos de tamaño fijo. En Java, se emplea una función hash para asignar un valor a una clave y luego almacenar o buscar ese valor utilizando esa clave.

**Características del Hashing en Java:**

-   **Función Hash:** Convierte una clave en un valor hash, que luego se utiliza para indexar en una tabla hash.
-   **Acceso Eficiente:** Permite un acceso rápido a los datos a través de la clave en tiempo constante.
-   **Evitar Colisiones:** Las colisiones ocurren cuando dos claves diferentes obtienen el mismo valor hash. Las técnicas de resolución de colisiones (como el encadenamiento o la resolución por dispersión) se utilizan para manejar estas situaciones.

Ejemplo de Hashing en Java:

```java
import java.util.*;

class HashingDemo {
    public static void main(String[] args) {
        HashSet<Integer> set = new HashSet<>();
        
        // Agregar elementos a la tabla hash
        set.add(5);
        set.add(10);
        set.add(15);
        set.add(20);

        // Verificar si un elemento está presente
        boolean found = set.contains(10); // true

        // Eliminar un elemento de la tabla hash
        set.remove(15);

        // Mostrar los elementos en la tabla hash
        System.out.println("Elementos en la tabla hash: " + set); 
        // Salida: [5, 10, 20]
    }
}
```
### Graph ( grafo )
Es una estructura de datos que consiste en un conjunto de nodos (vértices) y un conjunto de aristas (conexiones) que unen estos nodos. En Java, los grafos se pueden representar de varias maneras, como una matriz de adyacencia o una lista de adyacencia, y se utilizan para modelar relaciones entre entidades.

**Características de los Grafos en Java:**

-   **Nodos y Conexiones:** Los nodos representan entidades, y las aristas representan las relaciones entre estas entidades.
-   **Dirigidos o No Dirigidos:** Los grafos pueden ser dirigidos (las aristas tienen una dirección) o no dirigidos (las aristas no tienen dirección).
-   **Representación Flexible:** Pueden ser representados utilizando matrices de adyacencia o listas de adyacencia, dependiendo de los requisitos.

Ejemplo de Grafo en Java (Representación con Lista de Adyacencia):

```java
import java.util.*;

class Graph {
    int V;
    LinkedList<Integer>[] adjList;

    Graph(int vertices) {
        V = vertices;
        adjList = new LinkedList[V];
        for (int i = 0; i < V; ++i) {
            adjList[i] = new LinkedList();
        }
    }

    void addEdge(int v, int w) {
        adjList[v].add(w); 
        // Añadir una conexión de v a w
    }

    void BFS(int s) {
        boolean[] visited = new boolean[V];
        LinkedList<Integer> queue = new LinkedList<>();
        visited[s] = true;
        queue.add(s);

        while (queue.size() != 0) {
            s = queue.poll();
            System.out.print(s + " ");

            Iterator<Integer> itr = adjList[s].listIterator();
            while (itr.hasNext()) {
                int n = itr.next();
                if (!visited[n]) {
                    visited[n] = true;
                    queue.add(n);
                }
            }
        }
    }

    public static void main(String args[]) {
        Graph g = new Graph(4);
        g.addEdge(0, 1);
        g.addEdge(0, 2);
        g.addEdge(1, 2);
        g.addEdge(2, 0);
        g.addEdge(2, 3);
        g.addEdge(3, 3);

        System.out.println("Recorrido BFS desde el vértice 2:");
        g.BFS(2);
    }
}
```



# Preguntas Frecuentes sobre Estructuras de Datos en Java

### P: ¿Cuál es la diferencia entre un array y una lista enlazada?

R: Los arrays tienen tamaños fijos y asignación de memoria contigua, lo que permite el acceso aleatorio. En cambio, las listas enlazadas pueden crecer dinámicamente, tienen memoria no contigua y ofrecen una inserción/eliminación eficiente.

### P: ¿Cuándo debo usar una pila o una cola?

R: Usa una pila para operaciones de Last In, First Out (LIFO), mientras que una cola es adecuada para operaciones de First In, First Out (FIFO).